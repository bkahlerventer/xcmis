/**
 * Copyright (C) 2010 eXo Platform SAS.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 */

package org.xcmis.sp.inmemory;

import org.exoplatform.services.security.ConversationState;
import org.xcmis.core.CmisAccessControlEntryType;
import org.xcmis.core.CmisAccessControlListType;
import org.xcmis.core.CmisAccessControlPrincipalType;
import org.xcmis.core.CmisAllowableActionsType;
import org.xcmis.core.CmisObjectType;
import org.xcmis.core.CmisPropertiesType;
import org.xcmis.core.CmisProperty;
import org.xcmis.core.CmisPropertyBoolean;
import org.xcmis.core.CmisPropertyDateTime;
import org.xcmis.core.CmisPropertyDecimal;
import org.xcmis.core.CmisPropertyDefinitionType;
import org.xcmis.core.CmisPropertyHtml;
import org.xcmis.core.CmisPropertyId;
import org.xcmis.core.CmisPropertyInteger;
import org.xcmis.core.CmisPropertyString;
import org.xcmis.core.CmisPropertyUri;
import org.xcmis.core.CmisRenditionType;
import org.xcmis.core.CmisTypeDefinitionType;
import org.xcmis.core.CmisTypeDocumentDefinitionType;
import org.xcmis.core.EnumACLPropagation;
import org.xcmis.core.EnumBaseObjectTypeIds;
import org.xcmis.core.EnumBasicPermissions;
import org.xcmis.core.EnumContentStreamAllowed;
import org.xcmis.core.EnumIncludeRelationships;
import org.xcmis.core.EnumRelationshipDirection;
import org.xcmis.core.EnumUnfileObject;
import org.xcmis.core.EnumUpdatability;
import org.xcmis.core.EnumVersioningState;
import org.xcmis.messaging.CmisObjectInFolderContainerType;
import org.xcmis.messaging.CmisObjectParentsType;
import org.xcmis.messaging.CmisTypeContainer;
import org.xcmis.spi.CMIS;
import org.xcmis.spi.CmisRuntimeException;
import org.xcmis.spi.Connection;
import org.xcmis.spi.ConstraintException;
import org.xcmis.spi.ContentAlreadyExistsException;
import org.xcmis.spi.FilterNotValidException;
import org.xcmis.spi.InvalidArgumentException;
import org.xcmis.spi.NameConstraintViolationException;
import org.xcmis.spi.ObjectNotFoundException;
import org.xcmis.spi.StorageException;
import org.xcmis.spi.StreamNotSupportedException;
import org.xcmis.spi.TypeNotFoundException;
import org.xcmis.spi.UpdateConflictException;
import org.xcmis.spi.VersioningException;
import org.xcmis.spi.object.BaseItemsIterator;
import org.xcmis.spi.object.ContentStream;
import org.xcmis.spi.object.ItemsIterator;

import java.io.IOException;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.Map.Entry;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.regex.Pattern;

/**
 * @author <a href="mailto:andrew00x@gmail.com">Andrey Parfonov</a>
 * @version $Id: $
 */
public class InMemConnection implements Connection
{

   /** Characters that split. */
   private static final Pattern SPLITTER = Pattern.compile("\\s*,\\s*");

   /** Characters that not allowed in property name. */
   private static final String ILLEGAL_CHARACTERS = ",\"'\\.()";

   private final InMemStorage storage;

   private final ConversationState user;

   public InMemConnection(InMemStorage storage, ConversationState user)
   {
      this.storage = storage;
      this.user = user;
   }

   /**
    * {@inheritDoc}
    */
   public void addACEs(String objectId, CmisAccessControlListType aces, EnumACLPropagation propagation)
      throws CmisRuntimeException
   {
      Map<String, Set<String>> permissions = storage.acls.get(objectId);
      if (permissions == null)
      {
         permissions = new ConcurrentHashMap<String, Set<String>>();
         storage.acls.put(objectId, permissions);
      }
      Map<String, Set<String>> newPermissions = getPermissionMap(aces);
      for (Map.Entry<String, Set<String>> e : newPermissions.entrySet())
      {
         Set<String> values = permissions.get(e.getKey());
         if (values != null)
            values.addAll(e.getValue());
         else
            permissions.put(e.getKey(), new CopyOnWriteArraySet<String>(e.getValue()));
      }
   }

   /**
    * {@inheritDoc}
    */
   public void addObjectToFolder(String objectId, String folderId, boolean allVersions) throws CmisRuntimeException
   {
      storage.parents.get(objectId).add(folderId);
      storage.children.get(folderId).add(objectId);
   }

   public void addType(CmisTypeDefinitionType type) throws CmisRuntimeException
   {
      // TODO Auto-generated method stub
   }

   /**
    * {@inheritDoc}
    */
   public void applyPolicy(String policyId, String objectId) throws ConstraintException, ObjectNotFoundException,
      CmisRuntimeException
   {
      Set<String> policyIDs = storage.policies.get(objectId);
      if (policyIDs == null)
      {
         policyIDs = new CopyOnWriteArraySet<String>();
         storage.policies.put(objectId, policyIDs);
      }
      policyIDs.add(policyId);
   }

   public void cancelCheckout(String documentId) throws ConstraintException, UpdateConflictException,
      VersioningException, StorageException, CmisRuntimeException
   {
      // TODO Auto-generated method stub

   }

   public CmisObjectType checkin(String documentId, boolean major, CmisPropertiesType properties,
      ContentStream content, String checkinComment, CmisAccessControlListType addACL,
      CmisAccessControlListType removeACL, List<String> policies) throws ConstraintException, UpdateConflictException,
      StreamNotSupportedException, IOException, StorageException
   {
      // TODO Auto-generated method stub
      return null;
   }

   public CmisObjectType checkout(String documentId) throws ConstraintException, UpdateConflictException,
      VersioningException, StorageException, CmisRuntimeException
   {
      // TODO Auto-generated method stub
      return null;
   }

   /**
    * {@inheritDoc}
    */
   public void close()
   {
   }

   public CmisObjectType createDocument(String folderId, CmisPropertiesType properties, ContentStream content,
      CmisAccessControlListType addACEs, CmisAccessControlListType removeACEs, List<String> policies,
      EnumVersioningState versioningState) throws ObjectNotFoundException, ConstraintException,
      InvalidArgumentException, StreamNotSupportedException, NameConstraintViolationException, IOException,
      StorageException, CmisRuntimeException
   {

      CmisPropertyId typeId = (CmisPropertyId)getProperty(properties, CMIS.OBJECT_TYPE_ID);
      if (typeId == null || typeId.getValue().size() == 0)
         throw new ConstraintException("Type is not specified.");

      CmisTypeDefinitionType typeDefinition = getTypeDefinition(typeId.getValue().get(0));

      checkTypeDefinition(typeDefinition, EnumBaseObjectTypeIds.CMIS_DOCUMENT);

      if (folderId != null)
         validateFolder(folderId, typeId.getValue().get(0));

      String name = getName(properties);
      if (name == null)
         throw new NameConstraintViolationException("Name is not specified.");

      String newDocId = InMemStorage.generateId();
      String vsId = InMemStorage.generateId();

      Map<String, PropertyData<?>> newProperties = new ConcurrentHashMap<String, PropertyData<?>>();

      addBaseProperties(newProperties, newDocId, name, typeDefinition);

      newProperties.put(CMIS.IS_IMMUTABLE, new BooleanPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.IS_IMMUTABLE), false));
      newProperties.put(CMIS.IS_LATEST_VERSION, new BooleanPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.IS_LATEST_VERSION), true));
      newProperties.put(CMIS.IS_MAJOR_VERSION, new BooleanPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.IS_MAJOR_VERSION), versioningState == EnumVersioningState.MAJOR));
      newProperties.put(CMIS.VERSION_LABEL, new StringPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.VERSION_LABEL), versioningState == EnumVersioningState.CHECKEDOUT ? "pwc"
         : "current"));
      newProperties.put(CMIS.IS_VERSION_SERIES_CHECKED_OUT, new BooleanPropertyData(getPropertyDefinition(
         typeDefinition.getPropertyDefinition(), CMIS.IS_VERSION_SERIES_CHECKED_OUT),
         versioningState == EnumVersioningState.CHECKEDOUT));
      newProperties.put(CMIS.VERSION_SERIES_CHECKED_OUT_ID, new IdPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.VERSION_SERIES_CHECKED_OUT_ID),
         versioningState == EnumVersioningState.CHECKEDOUT ? newDocId : null));
      newProperties.put(CMIS.VERSION_SERIES_CHECKED_OUT_BY, new IdPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.VERSION_SERIES_CHECKED_OUT_BY),
         versioningState == EnumVersioningState.CHECKEDOUT && user != null ? user.getIdentity().getUserId() : null));
      newProperties.put(CMIS.VERSION_SERIES_ID, new IdPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.VERSION_SERIES_ID), vsId));
      newProperties.put(CMIS.CONTENT_STREAM_LENGTH, new IntegerPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.CONTENT_STREAM_LENGTH), BigInteger.valueOf(content != null ? content.length()
         : 0)));
      newProperties.put(CMIS.CONTENT_STREAM_MIME_TYPE, new StringPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.CONTENT_STREAM_MIME_TYPE), content != null ? content.getMediaType() : null));
      newProperties.put(CMIS.CONTENT_STREAM_FILE_NAME, new StringPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.CONTENT_STREAM_FILE_NAME), content != null ? name : null));
      newProperties.put(CMIS.CONTENT_STREAM_ID, new IdPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.CONTENT_STREAM_ID), content != null ? newDocId : null));

      // TODO : Add custom properties.

      storage.properties.put(newDocId, newProperties);

      if (folderId != null)
         storage.children.get(folderId).add(newDocId);

      Set<String> parentsSet = new CopyOnWriteArraySet<String>();
      if (folderId != null)
         parentsSet.add(folderId);
      storage.parents.put(newDocId, parentsSet);

      Set<String> versionSet = new CopyOnWriteArraySet<String>();
      versionSet.add(newDocId);
      storage.versions.put(vsId, versionSet);

      if (policies != null && policies.size() > 0 && !typeDefinition.isControllablePolicy())
         throw new ConstraintException("Type " + typeId + " is not controllable by policies but policies provided.");

      if (((addACEs != null && addACEs.getPermission().size() > 0) || (removeACEs != null && removeACEs.getPermission()
         .size() > 0))
         && !typeDefinition.isControllableACL())
         throw new ConstraintException("Type " + typeId + " is not controllable by ACL but ACL provided.");

      if (addACEs != null)
         storage.acls.put(newDocId, new ConcurrentHashMap<String, Set<String>>(getPermissionMap(addACEs)));

      if (policies != null)
         storage.policies.put(newDocId, new CopyOnWriteArraySet<String>(policies));

      if (content != null)
         storage.contents.put(newDocId, content);

      CmisObjectType newDoc = new CmisObjectType();
      newDoc.setProperties(createCmisProperties(newProperties));
      return newDoc;
   }

   public CmisObjectType createDocument(String folderId, CmisTypeDefinitionType typeDefinition,
      CmisPropertiesType properties, ContentStream content, CmisAccessControlListType addACEs,
      CmisAccessControlListType removeACEs, List<String> policies, EnumVersioningState versioningState)
      throws NameConstraintViolationException, IOException, StorageException, CmisRuntimeException
   {
      String name = getName(properties);
      if (name == null)
         throw new NameConstraintViolationException("Name is not specified.");

      String newDocId = InMemStorage.generateId();
      String vsId = InMemStorage.generateId();

      Map<String, PropertyData<?>> newProperties = new ConcurrentHashMap<String, PropertyData<?>>();

      addBaseProperties(newProperties, newDocId, name, typeDefinition);

      newProperties.put(CMIS.IS_IMMUTABLE, new BooleanPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.IS_IMMUTABLE), false));
      newProperties.put(CMIS.IS_LATEST_VERSION, new BooleanPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.IS_LATEST_VERSION), true));
      newProperties.put(CMIS.IS_MAJOR_VERSION, new BooleanPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.IS_MAJOR_VERSION), versioningState == EnumVersioningState.MAJOR));
      newProperties.put(CMIS.VERSION_LABEL, new StringPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.VERSION_LABEL), versioningState == EnumVersioningState.CHECKEDOUT ? "pwc"
         : "current"));
      newProperties.put(CMIS.IS_VERSION_SERIES_CHECKED_OUT, new BooleanPropertyData(getPropertyDefinition(
         typeDefinition.getPropertyDefinition(), CMIS.IS_VERSION_SERIES_CHECKED_OUT),
         versioningState == EnumVersioningState.CHECKEDOUT));
      newProperties.put(CMIS.VERSION_SERIES_CHECKED_OUT_ID, new IdPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.VERSION_SERIES_CHECKED_OUT_ID),
         versioningState == EnumVersioningState.CHECKEDOUT ? newDocId : null));
      newProperties.put(CMIS.VERSION_SERIES_CHECKED_OUT_BY, new IdPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.VERSION_SERIES_CHECKED_OUT_BY),
         versioningState == EnumVersioningState.CHECKEDOUT && user != null ? user.getIdentity().getUserId() : null));
      newProperties.put(CMIS.VERSION_SERIES_ID, new IdPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.VERSION_SERIES_ID), vsId));
      newProperties.put(CMIS.CONTENT_STREAM_LENGTH, new IntegerPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.CONTENT_STREAM_LENGTH), BigInteger.valueOf(content != null ? content.length()
         : 0)));
      newProperties.put(CMIS.CONTENT_STREAM_MIME_TYPE, new StringPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.CONTENT_STREAM_MIME_TYPE), content != null ? content.getMediaType() : null));
      newProperties.put(CMIS.CONTENT_STREAM_FILE_NAME, new StringPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.CONTENT_STREAM_FILE_NAME), content != null ? name : null));
      newProperties.put(CMIS.CONTENT_STREAM_ID, new IdPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.CONTENT_STREAM_ID), content != null ? newDocId : null));

      // TODO : Add custom properties.

      storage.properties.put(newDocId, newProperties);

      if (folderId != null)
         storage.children.get(folderId).add(newDocId);

      Set<String> parentsSet = new CopyOnWriteArraySet<String>();
      if (folderId != null)
         parentsSet.add(folderId);
      storage.parents.put(newDocId, parentsSet);

      Set<String> versionSet = new CopyOnWriteArraySet<String>();
      versionSet.add(newDocId);
      storage.versions.put(vsId, versionSet);

      if (addACEs != null)
         storage.acls.put(newDocId, new ConcurrentHashMap<String, Set<String>>(getPermissionMap(addACEs)));

      if (policies != null)
         storage.policies.put(newDocId, new CopyOnWriteArraySet<String>(policies));

      CmisObjectType newDoc = new CmisObjectType();
      newDoc.setProperties(createCmisProperties(newProperties));
      return newDoc;
   }

   public CmisObjectType createDocumentFromSource(CmisObjectType source, String name, String folderId,
      CmisPropertiesType properties, CmisAccessControlListType addACEs, CmisAccessControlListType removeACEs,
      List<String> policies, EnumVersioningState versioningState) throws NameConstraintViolationException,
      StorageException, CmisRuntimeException
   {
      String typeId = getTypeId(source.getProperties());
      if (typeId == null)
         // this shouldn't happen, because specified source should contain typeId
         throw new CmisRuntimeException("Type is not provided.");

      String sourceId = getId(source.getProperties());
      if (sourceId == null)
         // this shouldn't happen, because specified source should contain id
         throw new CmisRuntimeException("Source id is not provided.");

      CmisTypeDefinitionType typeDefinition = getTypeDefinition(typeId);

      String docId = InMemStorage.generateId();
      String vsId = InMemStorage.generateId();
      Calendar date = Calendar.getInstance();

      Map<String, PropertyData<?>> newProperties = new ConcurrentHashMap<String, PropertyData<?>>();

      // Copy properties
      for (Map.Entry<String, PropertyData<?>> e : storage.properties.get(sourceId).entrySet())
      {
         if (e.getKey().equals(CMIS.OBJECT_ID) || e.getKey().equals(CMIS.CREATION_DATE)
            || e.getKey().equals(CMIS.CREATED_BY) || (name != null && e.getKey().equals(CMIS.NAME)))
            continue;
         //    TODO     newProperties.put(e.getKey(), e.getValue().clone());
      }

      // Set properties that must be different from original object.
      newProperties.put(CMIS.OBJECT_ID, new IdPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.OBJECT_ID), docId));
      newProperties.put(CMIS.CREATED_BY, new StringPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.CREATED_BY), user != null ? user.getIdentity().getUserId() : null));
      newProperties.put(CMIS.CREATION_DATE, new DateTimePropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.CREATION_DATE), date));
      newProperties.put(CMIS.LAST_MODIFIED_BY, new StringPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.LAST_MODIFIED_BY), user != null ? user.getIdentity().getUserId() : null));
      newProperties.put(CMIS.LAST_MODIFICATION_DATE, new DateTimePropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.LAST_MODIFICATION_DATE), date));
      if (name != null)
         newProperties.put(CMIS.NAME, new StringPropertyData(getPropertyDefinition(typeDefinition
            .getPropertyDefinition(), CMIS.NAME), name));

      // TODO : custom properties

      storage.properties.put(docId, newProperties);
      if (folderId != null)
         storage.children.get(folderId).add(docId);
      Set<String> parentsSet = new CopyOnWriteArraySet<String>();
      if (folderId != null)
         parentsSet.add(folderId);
      storage.parents.put(docId, parentsSet);
      Set<String> versionSet = new CopyOnWriteArraySet<String>();
      versionSet.add(docId);
      storage.versions.put(vsId, versionSet);
      if (policies != null && policies.size() > 0 && !typeDefinition.isControllablePolicy())
         throw new ConstraintException("Type " + typeId + " is not controllable by policies but policies provided.");

      if (addACEs != null)
         storage.acls.put(docId, new ConcurrentHashMap<String, Set<String>>(getPermissionMap(addACEs)));

      if (policies != null)
         storage.policies.put(docId, new CopyOnWriteArraySet<String>(policies));

      CmisObjectType newDoc = new CmisObjectType();
      newDoc.setProperties(createCmisProperties(newProperties));
      return newDoc;
   }

   public CmisObjectType createDocumentFromSource(String sourceId, String folderId, CmisPropertiesType properties,
      CmisAccessControlListType addACEs, CmisAccessControlListType removeACEs, List<String> policies,
      EnumVersioningState versioningState) throws ObjectNotFoundException, ConstraintException,
      InvalidArgumentException, NameConstraintViolationException, StorageException, CmisRuntimeException
   {
      /* 
            CmisObjectType source = null;

            try
            {
               source = getObject(sourceId, false, EnumIncludeRelationships.NONE, false, false, CMIS.WILDCARD, "cmis:none");
            }
            catch (FilterNotValidException e)
            {
               // this shouldn't happen, because filter is prepared and valid
               throw new CmisRuntimeException(e);
            }

            CmisPropertyId typeId = (CmisPropertyId)getProperty(source.getProperties(), CMIS.OBJECT_TYPE_ID);
            if (typeId == null || typeId.getValue().size() == 0)
               throw new ConstraintException("Type is not specified.");

            CmisTypeDefinitionType typeDefinition = getTypeDefinition(typeId.getValue().get(0));

            if (folderId != null)
               validateFolder(folderId, typeId.getValue().get(0));

            CmisPropertyString name = (CmisPropertyString)getProperty(properties, CMIS.NAME);
            if (name == null || name.getValue().size() == 0)
               throw new NameConstraintViolationException("Name is not specified.");

            String docId = InMemStorage.generateId();
            String vsId = InMemStorage.generateId();
            Calendar date = Calendar.getInstance();

            Map<String, PropertyAdapter<? extends CmisProperty>> newProperties =
               new ConcurrentHashMap<String, PropertyAdapter<? extends CmisProperty>>();

            // Copy properties
            for (Map.Entry<String, PropertyAdapter<? extends CmisProperty>> e : storage.properties.get(sourceId).entrySet())
            {
               if (!e.getKey().equals(CMIS.OBJECT_ID) && !e.getKey().equals(CMIS.CREATION_DATE)
                  && !e.getKey().equals(CMIS.CREATED_BY))
                  newProperties.put(e.getKey(), e.getValue().clone());
            }

            // Set properties that must be different from original object.
            newProperties.put(CMIS.OBJECT_ID, new IdPropertyAdapter(getPropertyDefinition(typeDefinition
               .getPropertyDefinition(), CMIS.OBJECT_ID), docId));

            newProperties.put(CMIS.CREATED_BY, new StringPropertyAdapter(getPropertyDefinition(typeDefinition
               .getPropertyDefinition(), CMIS.CREATED_BY), user != null ? user.getIdentity().getUserId() : null));

            newProperties.put(CMIS.CREATION_DATE, new DateTimePropertyAdapter(getPropertyDefinition(typeDefinition
               .getPropertyDefinition(), CMIS.CREATION_DATE), date));

            newProperties.put(CMIS.LAST_MODIFIED_BY, new StringPropertyAdapter(getPropertyDefinition(typeDefinition
               .getPropertyDefinition(), CMIS.LAST_MODIFIED_BY), user != null ? user.getIdentity().getUserId() : null));

            newProperties.put(CMIS.LAST_MODIFICATION_DATE, new DateTimePropertyAdapter(getPropertyDefinition(typeDefinition
               .getPropertyDefinition(), CMIS.LAST_MODIFICATION_DATE), date));

            // TODO : custom properties

            storage.properties.put(docId, newProperties);

            if (folderId != null)
               storage.children.get(folderId).add(docId);

            Set<String> parentsSet = new CopyOnWriteArraySet<String>();
            if (folderId != null)
               parentsSet.add(folderId);
            storage.parents.put(docId, parentsSet);

            Set<String> versionSet = new CopyOnWriteArraySet<String>();
            versionSet.add(docId);
            storage.versions.put(vsId, versionSet);

            if (policies != null && policies.size() > 0 && !typeDefinition.isControllablePolicy())
               throw new ConstraintException("Type " + typeId + " is not controllable by policies but policies provided.");

            CopyOnWriteArraySet<String> policiesSet = new CopyOnWriteArraySet<String>();
            if (policies != null)
               policiesSet.addAll(policies);
            storage.policies.put(docId, policiesSet);

            if (((addACEs != null && addACEs.getPermission().size() > 0) || (removeACEs != null && removeACEs.getPermission()
               .size() > 0))
               && !typeDefinition.isControllableACL())
               throw new ConstraintException("Type " + typeId + " is not controllable by ACL but ACL provided.");

            storage.acls.put(docId, new ConcurrentHashMap<String, Set<String>>(getPermissionMap(addACEs)));

            CmisObjectType newDoc = new CmisObjectType();
            newDoc.setProperties(createCmisProperties(newProperties));
            return newDoc;
      */
      return null;
   }

   public CmisObjectType createFolder(String folderId, CmisPropertiesType properties,
      CmisAccessControlListType addACEs, CmisAccessControlListType removeACEs, List<String> policies)
      throws ObjectNotFoundException, ConstraintException, InvalidArgumentException, NameConstraintViolationException,
      StorageException, CmisRuntimeException
   {
      String typeId = getTypeId(properties);
      if (typeId == null)
         throw new ConstraintException("Type is not specified.");

      CmisTypeDefinitionType typeDefinition = getTypeDefinition(typeId);

      checkTypeDefinition(typeDefinition, EnumBaseObjectTypeIds.CMIS_FOLDER);

      if (folderId == null)
         throw new ConstraintException("Parent folder id is not provided.");

      String name = getName(properties);
      if (name == null)
         throw new NameConstraintViolationException("Name is not provided.");

      String newFolderId = InMemStorage.generateId();

      Map<String, PropertyData<?>> newProperties = new ConcurrentHashMap<String, PropertyData<?>>();

      addBaseProperties(newProperties, newFolderId, name, typeDefinition);

      newProperties.put(CMIS.PARENT_ID, new IdPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.PARENT_ID), folderId));

      String path = calculateFolderPath(folderId).append('/').append(name).toString();
      newProperties.put(CMIS.PATH, new StringPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.PATH), path));

      // TODO : Add custom properties.

      storage.properties.put(newFolderId, newProperties);

      storage.children.put(newFolderId, new CopyOnWriteArraySet<String>());

      storage.children.get(folderId).add(newFolderId);

      Set<String> parentsSet = new CopyOnWriteArraySet<String>();
      parentsSet.add(folderId);
      storage.parents.put(newFolderId, parentsSet);

      if (addACEs != null)
         storage.acls.put(newFolderId, new ConcurrentHashMap<String, Set<String>>(getPermissionMap(addACEs)));

      if (policies != null)
         storage.policies.put(newFolderId, new CopyOnWriteArraySet<String>(policies));

      CmisObjectType newFolder = new CmisObjectType();
      newFolder.setProperties(createCmisProperties(newProperties));
      return newFolder;
   }

   public CmisObjectType createFolder(String folderId, CmisTypeDefinitionType typeDefinition,
      CmisPropertiesType properties, CmisAccessControlListType addACEs, CmisAccessControlListType removeACEs,
      List<String> policies) throws NameConstraintViolationException, StorageException, CmisRuntimeException
   {
      String name = getName(properties);
      if (name == null)
         throw new NameConstraintViolationException("Name is not provided.");

      String newFolderId = InMemStorage.generateId();

      Map<String, PropertyData<?>> newProperties = new ConcurrentHashMap<String, PropertyData<?>>();

      addBaseProperties(newProperties, newFolderId, name, typeDefinition);

      newProperties.put(CMIS.PARENT_ID, new IdPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.PARENT_ID), folderId));
      String path = calculateFolderPath(folderId).append('/').append(name).toString();
      newProperties.put(CMIS.PATH, new StringPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.PATH), path));

      // TODO : Add custom properties.

      storage.properties.put(newFolderId, newProperties);

      storage.children.put(newFolderId, new CopyOnWriteArraySet<String>());

      storage.children.get(folderId).add(newFolderId);

      Set<String> parentsSet = new CopyOnWriteArraySet<String>();
      parentsSet.add(folderId);
      storage.parents.put(newFolderId, parentsSet);

      if (addACEs != null)
         storage.acls.put(newFolderId, new ConcurrentHashMap<String, Set<String>>(getPermissionMap(addACEs)));

      if (policies != null)
         storage.policies.put(newFolderId, new CopyOnWriteArraySet<String>(policies));

      CmisObjectType newFolder = new CmisObjectType();
      newFolder.setProperties(createCmisProperties(newProperties));
      return newFolder;
   }

   public CmisObjectType createPolicy(String folderId, CmisPropertiesType properties,
      CmisAccessControlListType addACEs, CmisAccessControlListType removeACEs, List<String> policies)
      throws ObjectNotFoundException, ConstraintException, InvalidArgumentException, NameConstraintViolationException,
      StorageException, CmisRuntimeException
   {
      // TODO Auto-generated method stub
      String typeId = getTypeId(properties);
      return createPolicy(folderId, getTypeDefinition(typeId), properties, addACEs, removeACEs, policies);
   }

   public CmisObjectType createPolicy(String folderId, CmisTypeDefinitionType typeDefinition,
      CmisPropertiesType properties, CmisAccessControlListType addACEs, CmisAccessControlListType removeACEs,
      List<String> policies) throws NameConstraintViolationException, StorageException, CmisRuntimeException
   {
      String name = getName(properties);
      if (name == null)
         throw new NameConstraintViolationException("Name is not provided.");

      String newPolicyId = InMemStorage.generateId();

      Map<String, PropertyData<?>> newProperties = new ConcurrentHashMap<String, PropertyData<?>>();

      addBaseProperties(newProperties, newPolicyId, name, typeDefinition);

      newProperties.put(CMIS.POLICY_TEXT, new StringPropertyData( //
         getPropertyDefinition(typeDefinition.getPropertyDefinition(), CMIS.POLICY_TEXT), //
         ((CmisPropertyString)getProperty(properties, CMIS.POLICY_TEXT)).getValue().get(0)));

      storage.properties.put(newPolicyId, newProperties);

      storage.children.get(folderId).add(newPolicyId);

      Set<String> parentsSet = new CopyOnWriteArraySet<String>();
      parentsSet.add(folderId);
      storage.parents.put(newPolicyId, parentsSet);

      if (addACEs != null)
         storage.acls.put(newPolicyId, new ConcurrentHashMap<String, Set<String>>(getPermissionMap(addACEs)));

      if (policies != null)
         storage.policies.put(newPolicyId, new CopyOnWriteArraySet<String>(policies));

      CmisObjectType newFolder = new CmisObjectType();
      newFolder.setProperties(createCmisProperties(newProperties));
      return newFolder;
   }

   public CmisObjectType createRelationship(CmisPropertiesType properties, CmisAccessControlListType addACEs,
      CmisAccessControlListType removeACEs, List<String> policies) throws ObjectNotFoundException, ConstraintException,
      NameConstraintViolationException, StorageException, CmisRuntimeException
   {
      // TODO Auto-generated method stub
      return null;
   }

   public void deleteContentStream(String documentId, String changeToken) throws UpdateConflictException,
      StorageException, CmisRuntimeException
   {
      storage.contents.remove(documentId);
      Map<String, PropertyData<?>> properties = storage.properties.get(documentId);
      properties.get(CMIS.CONTENT_STREAM_ID).setValue(null);
      properties.get(CMIS.CONTENT_STREAM_MIME_TYPE).setValue(null);
      properties.get(CMIS.CONTENT_STREAM_FILE_NAME).setValue(null);
      ((IntegerPropertyData)properties.get(CMIS.CONTENT_STREAM_LENGTH)).setValue(BigInteger.valueOf(0));
   }

   public void deleteObject(String objectId, boolean deleteAllVersion) throws ObjectNotFoundException,
      ConstraintException, UpdateConflictException, StorageException, CmisRuntimeException
   {
      deleteObject1(objectId, deleteAllVersion);
   }

   public void deleteObject1(String objectId, boolean deleteAllVersion) throws UpdateConflictException,
      StorageException, CmisRuntimeException
   {
      storage.parents.remove(objectId);
      storage.contents.remove(objectId);
      storage.acls.remove(objectId);
      storage.policies.remove(objectId);
      storage.properties.remove(objectId);
   }

   public List<String> deleteTree(String folderId, EnumUnfileObject unfileObjects, boolean continueOnFailure)
      throws ObjectNotFoundException, UpdateConflictException, StorageException, CmisRuntimeException
   {
      // TODO Auto-generated method stub
      return null;
   }

   public CmisAccessControlListType getACL(String objectId, boolean onlyBasicPermissions) throws CmisRuntimeException
   {
      if (storage.acls.get(objectId) != null)
         return createCmisACL(storage.acls.get(objectId));
      return null;
   }

   public CmisAllowableActionsType getAllowableActions(String objectId) throws ObjectNotFoundException,
      CmisRuntimeException
   {
      try
      {
         return getObject(objectId, true, EnumIncludeRelationships.NONE, false, false, "cmis:objectId", "cmis:none")
            .getAllowableActions();
      }
      catch (FilterNotValidException e)
      {
         // this shouldn't happen, because filter is prepared and valid
         throw new CmisRuntimeException(e);
      }
   }

   public ItemsIterator<CmisObjectType> getAllVersions(String versionSeriesId, boolean includeAllowableActions,
      String propertyFilter) throws ObjectNotFoundException, FilterNotValidException, CmisRuntimeException
   {
      // TODO Auto-generated method stub
      return null;
   }

   public ItemsIterator<CmisObjectType> getAppliedPolicies(String objectId, String propertyFilter)
      throws ObjectNotFoundException, FilterNotValidException, CmisRuntimeException
   {
      Set<String> policyIDs = storage.policies.get(objectId);
      List<CmisObjectType> policies = new ArrayList<CmisObjectType>();
      if (policyIDs != null)
      {
         for (String id : policyIDs)
            policies
               .add(getObject(id, false, EnumIncludeRelationships.NONE, false, false, propertyFilter, "cmis:none"));
      }
      return new BaseItemsIterator<CmisObjectType>(policies);
   }

   public ItemsIterator<CmisObjectType> getCheckedOutDocs(String folderId, boolean includeAllowableActions,
      EnumIncludeRelationships includeRelationships, String propertyFilter, String renditionFilter, String orderBy)
      throws ObjectNotFoundException, InvalidArgumentException, FilterNotValidException, CmisRuntimeException
   {
      // TODO Auto-generated method stub
      return null;
   }

   public ItemsIterator<CmisObjectType> getChildren(String folderId, boolean includeAllowableActions,
      EnumIncludeRelationships includeRelationships, boolean includePathSegments, String propertyFilter,
      String renditionFilter, String orderBy) throws ObjectNotFoundException, InvalidArgumentException,
      FilterNotValidException, CmisRuntimeException
   {
      // TODO Auto-generated method stub
      return null;
   }

   public ItemsIterator<CmisObjectType> getContentChanges(String changeLogToken, boolean includeProperties,
      String propertyFilter, boolean includePolicyIds, boolean includeACL) throws ConstraintException,
      FilterNotValidException, CmisRuntimeException
   {
      // TODO Auto-generated method stub
      return null;
   }

   public ContentStream getContentStream(String objectId, String streamId, long offset, long length)
      throws CmisRuntimeException
   {
      if (streamId != null)
         return storage.contents.get(streamId);
      return storage.contents.get(objectId);
   }

   public CmisObjectType getFolderParent(String folderId, String propertyFilter) throws FilterNotValidException,
      CmisRuntimeException
   {
      Set<String> parents = storage.parents.get(folderId);
      if (parents.size() == 0)
         return null;
      return getObject(parents.iterator().next(), false, EnumIncludeRelationships.NONE, false, false, propertyFilter,
         "cmis:none");
   }

   public CmisObjectType getObject(String objectId, boolean includeAllowableActions,
      EnumIncludeRelationships includeRelationships, boolean includePolicyIds, boolean includeACL,
      String propertyFilter, String renditionFilter) throws ObjectNotFoundException, FilterNotValidException,
      CmisRuntimeException
   {
      Map<String, PropertyData<?>> properties = storage.properties.get(objectId);
      if (properties == null)
         throw new ObjectNotFoundException("Object " + objectId + " not found in storage.");

      String typeId = ((CmisPropertyId)properties.get(CMIS.OBJECT_TYPE_ID).getProperty()).getValue().get(0);

      CmisTypeDefinitionType typeDefinition = getTypeDefinition(typeId, true);
      Collection<String> propertyNames = parsePropertyFilter(propertyFilter, typeDefinition);

      CmisObjectType object = new CmisObjectType();

      object.setProperties(createCmisProperties(properties, propertyNames));

      if (includeAllowableActions)
         object.setAllowableActions(getAllowableActions(typeDefinition));

      return object;
   }

   public CmisObjectType getObjectByPath(String path, boolean includeAllowableActions,
      EnumIncludeRelationships includeRelationships, boolean includePolicyIds, boolean includeACL,
      String propertyFilter, String renditionFilter) throws ObjectNotFoundException, FilterNotValidException,
      CmisRuntimeException
   {
      if (!path.startsWith("/"))
         path = "/" + path;
      StringTokenizer tokenizer = new StringTokenizer(path, "/");
      String point = InMemStorage.ROOT_FOLDER_ID;
      while (tokenizer.hasMoreTokens())
      {
         if (point == null)
            break;
         String segName = tokenizer.nextToken();
         Set<String> childrenIDs = storage.children.get(point);
         if (childrenIDs == null || childrenIDs.isEmpty())
         {
            point = null;
         }
         else
         {
            for (String id : childrenIDs)
            {
               CmisObjectType seg =
                  getObject(id, false, EnumIncludeRelationships.NONE, false, false,
                     "cmis:objectTypeId,cmis:baseTypeId,cmis:name", "cmis:none");
               String baseTypeId = getBaseTypeId(seg.getProperties());
               String name = getName(seg.getProperties());
               if ((CMIS.FOLDER.equals(baseTypeId) || !tokenizer.hasMoreElements()) && segName.equals(name))
               {
                  point = id;
                  break;
               }
               point = null;
            }
         }
      }

      if (point == null)
         throw new ObjectNotFoundException("Path '" + path + "' not found.");

      return getObject(point, includeAllowableActions, includeRelationships, includePolicyIds, includeACL,
         propertyFilter, renditionFilter);
   }

   public CmisObjectType getObjectOfLatestVersion(String versionSeriesId, boolean major,
      boolean includeAllowableActions, EnumIncludeRelationships includeRelationships, boolean includePolicyIds,
      boolean includeACL, String propertyFilter, String renditionFilter) throws ObjectNotFoundException,
      FilterNotValidException, CmisRuntimeException
   {
      // TODO Auto-generated method stub
      return null;
   }

   public List<CmisObjectParentsType> getObjectParents(String objectId, boolean includeAllowableActions,
      EnumIncludeRelationships includeRelationships, boolean includeRelativePathSegment, String propertyFilter,
      String renditionFilter) throws ObjectNotFoundException, ConstraintException, FilterNotValidException,
      CmisRuntimeException
   {
      // TODO Auto-generated method stub
      return null;
   }

   public ItemsIterator<CmisObjectType> getObjectRelationships(String objectId, EnumRelationshipDirection direction,
      String typeId, boolean includeSubRelationshipTypes, boolean includeAllowableActions, String propertyFilter)
      throws FilterNotValidException, ObjectNotFoundException, StorageException
   {
      // TODO Auto-generated method stub
      return null;
   }

   public CmisPropertiesType getProperties(String objectId, String propertyFilter) throws ObjectNotFoundException,
      FilterNotValidException, CmisRuntimeException
   {
      return getObject(objectId, false, EnumIncludeRelationships.NONE, false, false, propertyFilter, "cmis:none")
         .getProperties();
   }

   public CmisPropertiesType getPropertiesOfLatestVersion(String versionSeriesId, boolean major, String propertyFilter)
      throws FilterNotValidException, ObjectNotFoundException, CmisRuntimeException
   {
      // TODO Auto-generated method stub
      return null;
   }

   public ItemsIterator<CmisRenditionType> getRenditions(String objectId, String renditionFilter)
      throws ObjectNotFoundException, FilterNotValidException, CmisRuntimeException
   {
      // TODO Auto-generated method stub
      return null;
   }

   public List<CmisObjectInFolderContainerType> getTree(String folderId, EnumBaseObjectTypeIds type, int depth,
      boolean includeAllowableActions, EnumIncludeRelationships includeRelationships, boolean includePathSegments,
      String propertyFilter, String renditionFilter) throws ObjectNotFoundException, InvalidArgumentException,
      FilterNotValidException, CmisRuntimeException
   {
      // TODO Auto-generated method stub
      return null;
   }

   public ItemsIterator<CmisTypeDefinitionType> getTypeChildren(String typeId, boolean includePropertyDefinition)
      throws TypeNotFoundException, CmisRuntimeException
   {
      // TODO Auto-generated method stub
      return null;
   }

   public CmisTypeDefinitionType getTypeDefinition(String typeId) throws TypeNotFoundException, CmisRuntimeException
   {
      return storage.getTypeDefinition(typeId, true);
   }

   public CmisTypeDefinitionType getTypeDefinition(String typeId, boolean includePropertyDefinition)
      throws TypeNotFoundException, CmisRuntimeException
   {
      return storage.getTypeDefinition(typeId, includePropertyDefinition);
   }

   public List<CmisTypeContainer> getTypeDescendants(String typeId, int depth, boolean includePropertyDefinition)
      throws TypeNotFoundException, CmisRuntimeException
   {
      // TODO Auto-generated method stub
      return null;
   }

   public CmisObjectType moveObject(String objectId, String targetFolderId, String sourceFolderId)
      throws ObjectNotFoundException, ConstraintException, InvalidArgumentException, UpdateConflictException,
      StorageException, CmisRuntimeException
   {
      // TODO Auto-generated method stub
      return null;
   }

   public ItemsIterator<CmisObjectType> query(String statement, boolean searchAllVersions,
      boolean includeAllowableActions, EnumIncludeRelationships includeRelationships, String renditionFilter)
      throws FilterNotValidException, CmisRuntimeException
   {
      // TODO Auto-generated method stub
      return null;
   }

   public void removeACEs(String objectId, CmisAccessControlListType aces, EnumACLPropagation propagation)
      throws ObjectNotFoundException, ConstraintException, CmisRuntimeException
   {
      // TODO Auto-generated method stub

   }

   public void removeObjectFromFolder(String objectId, String folderId) throws ObjectNotFoundException,
      CmisRuntimeException
   {
      // TODO Auto-generated method stub

   }

   public void removePolicy(String policyId, String objectId) throws ConstraintException, ObjectNotFoundException,
      CmisRuntimeException
   {
      // TODO Auto-generated method stub

   }

   public void removeType(String typeId) throws TypeNotFoundException, ConstraintException, StorageException,
      CmisRuntimeException
   {
      // TODO Auto-generated method stub

   }

   public void setContentStream(String documentId, ContentStream content, String changeToken, boolean overwriteFlag)
      throws ObjectNotFoundException, ContentAlreadyExistsException, StreamNotSupportedException,
      UpdateConflictException, IOException, StorageException, CmisRuntimeException
   {
      // TODO Auto-generated method stub

   }

   public void setContentStream(String documentId, ContentStream content, String changeToken)
      throws ObjectNotFoundException, UpdateConflictException, IOException, StorageException, CmisRuntimeException
   {
      //      storage.contents.put();
   }

   public CmisObjectType updateProperties(String objectId, String changeToken, CmisPropertiesType properties)
      throws ObjectNotFoundException, ConstraintException, NameConstraintViolationException, UpdateConflictException,
      StorageException, CmisRuntimeException
   {
      Map<String, PropertyData<?>> pDatas = storage.properties.get(objectId);
      if (pDatas == null)
         throw new ObjectNotFoundException("Object " + objectId + " does not exists.");

      String typeId = ((IdPropertyData)pDatas.get(CMIS.OBJECT_TYPE_ID)).getProperty().getValue().get(0);
      CmisTypeDefinitionType typeDefinition = getTypeDefinition(typeId);

      if (properties != null)
      {
         for (CmisProperty property : properties.getProperty())
         {
            String pId = property.getPropertyDefinitionId();
            CmisPropertyDefinitionType propertyDefinition =
               getPropertyDefinition(typeDefinition.getPropertyDefinition(), pId);

            if (propertyDefinition.getUpdatability() == EnumUpdatability.ONCREATE
               || propertyDefinition.getUpdatability() == EnumUpdatability.READONLY)
               continue;

            PropertyData<?> pData = pDatas.get(pId);
            switch (pData.getPropertyType())
            {
               case BOOLEAN :
                  ((BooleanPropertyData)pData).updateFromProperty((CmisPropertyBoolean)property);
                  break;
               case DATETIME :
                  ((DateTimePropertyData)pData).updateFromProperty((CmisPropertyDateTime)property);
                  break;
               case DECIMAL :
                  ((DecimalPropertyData)pData).updateFromProperty((CmisPropertyDecimal)property);
                  break;
               case HTML :
                  ((HtmlPropertyData)pData).updateFromProperty((CmisPropertyHtml)property);
                  break;
               case ID :
                  ((IdPropertyData)pData).updateFromProperty((CmisPropertyId)property);
                  break;
               case INTEGER :
                  ((IntegerPropertyData)pData).updateFromProperty((CmisPropertyInteger)property);
                  break;
               case STRING :
                  ((StringPropertyData)pData).updateFromProperty((CmisPropertyString)property);
                  break;
               case URI :
                  ((UriPropertyData)pData).updateFromProperty((CmisPropertyUri)property);
                  break;
            }
         }
      }

      // TODO Auto-generated method stub
      return null;
   }

   //////////////////////////////////////////////////////////////////////

   private void addBaseProperties(Map<String, PropertyData<?>> properties, String id, String name,
      CmisTypeDefinitionType typeDefinition)
   {
      Calendar date = Calendar.getInstance();
      properties.put(CMIS.OBJECT_ID, new IdPropertyData(getPropertyDefinition(
         typeDefinition.getPropertyDefinition(), CMIS.OBJECT_ID), id));
      properties.put(CMIS.NAME, new StringPropertyData(getPropertyDefinition(typeDefinition.getPropertyDefinition(),
         CMIS.NAME), name));
      properties.put(CMIS.OBJECT_TYPE_ID, new IdPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.OBJECT_TYPE_ID), typeDefinition.getId()));
      properties.put(CMIS.BASE_TYPE_ID, new IdPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.BASE_TYPE_ID), typeDefinition.getBaseId().value()));
      properties.put(CMIS.CREATED_BY, new StringPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.CREATED_BY), user != null ? user.getIdentity().getUserId() : null));
      properties.put(CMIS.CREATION_DATE, new DateTimePropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.CREATION_DATE), date));
      properties.put(CMIS.LAST_MODIFIED_BY, new StringPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.LAST_MODIFIED_BY), user != null ? user.getIdentity().getUserId() : null));
      properties.put(CMIS.LAST_MODIFICATION_DATE, new DateTimePropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.LAST_MODIFICATION_DATE), date));
      properties.put(CMIS.CHANGE_TOKEN, new StringPropertyData(getPropertyDefinition(typeDefinition
         .getPropertyDefinition(), CMIS.CHANGE_TOKEN), InMemStorage.generateId()));
   }

   private StringBuilder calculateFolderPath(String folderId)
   {
      CmisObjectType folder = null;
      try
      {
         folder =
            getObject(folderId, false, EnumIncludeRelationships.NONE, false, false, "cmis:objectId,cmis:name",
               "cmis:none");
      }
      catch (FilterNotValidException e)
      {
         // this shouldn't happen, because filter is prepared and valid
         throw new CmisRuntimeException(e);
      }

      LinkedList<String> pathSegms = new LinkedList<String>();
      pathSegms.add(getName(folder.getProperties()));

      CmisObjectType parent = getFolderParent(folderId, Arrays.asList(CMIS.OBJECT_ID, CMIS.NAME));
      while (parent != null)
      {
         String parentName = getName(parent.getProperties());
         String parentId = getId(parent.getProperties());
         pathSegms.add(parentName);
         parent = getFolderParent(parentId, Arrays.asList(CMIS.OBJECT_ID, CMIS.NAME));
      }

      StringBuilder path = new StringBuilder();
      for (String seg : pathSegms)
      {
         if (path.length() > 1)
            path.append('/');
         path.append(CMIS.ROOT_FOLDER_NAME.equals(seg) ? "/" : seg);
      }

      return path;
   }

   private void checkTypeDefinition(CmisTypeDefinitionType check, EnumBaseObjectTypeIds expected)
      throws ConstraintException
   {
      if (check.getBaseId() != expected)
         throw new ConstraintException("The typeId " + check.getId()
            + " represents object-type whose baseType is not a " + expected.value());
   }

   private CmisAccessControlListType createCmisACL(Map<String, Set<String>> map)
   {
      CmisAccessControlListType acl = new CmisAccessControlListType();
      for (Entry<String, Set<String>> e : map.entrySet())
      {
         CmisAccessControlEntryType ace = new CmisAccessControlEntryType();
         CmisAccessControlPrincipalType principal = new CmisAccessControlPrincipalType();
         principal.setPrincipalId(e.getKey());
         ace.getPermission().addAll(e.getValue());
         ace.setPrincipal(principal);
         acl.getPermission().add(ace);
      }
      return acl;
   }

   private CmisPropertiesType createCmisProperties(Map<String, PropertyData<?>> properties)
   {
      CmisPropertiesType cmisProperties = new CmisPropertiesType();
      for (PropertyData<?> pa : properties.values())
         cmisProperties.getProperty().add(pa.getProperty());
      return cmisProperties;
   }

   private CmisPropertiesType createCmisProperties(Map<String, PropertyData<?>> properties,
      Collection<String> propertyFilter)
   {
      CmisPropertiesType cmisProperties = new CmisPropertiesType();
      for (String name : propertyFilter)
      {
         PropertyData<?> pa = properties.get(name);
         if (pa != null)
            cmisProperties.getProperty().add(pa.getProperty());
      }
      return cmisProperties;
   }

   private CmisAllowableActionsType getAllowableActions(CmisTypeDefinitionType type)
   {
      CmisAllowableActionsType actions = new CmisAllowableActionsType();
      actions.setCanAddObjectToFolder(type.isFileable() && type.getBaseId() != EnumBaseObjectTypeIds.CMIS_FOLDER);
      actions.setCanApplyACL(type.isControllableACL());
      actions.setCanApplyPolicy(type.isControllablePolicy());
      actions.setCanCancelCheckOut(type.getBaseId() == EnumBaseObjectTypeIds.CMIS_DOCUMENT
         && ((CmisTypeDocumentDefinitionType)type).isVersionable())/* TODO */;
      actions.setCanCheckIn(type.getBaseId() == EnumBaseObjectTypeIds.CMIS_DOCUMENT
         && ((CmisTypeDocumentDefinitionType)type).isVersionable())/* TODO */;
      actions.setCanCheckOut(type.getBaseId() == EnumBaseObjectTypeIds.CMIS_DOCUMENT
         && ((CmisTypeDocumentDefinitionType)type).isVersionable())/* TODO */;
      actions.setCanCreateDocument(type.getBaseId() == EnumBaseObjectTypeIds.CMIS_FOLDER);
      actions.setCanCreateFolder(type.getBaseId() == EnumBaseObjectTypeIds.CMIS_FOLDER);
      actions.setCanCreateRelationship(type.getBaseId() != EnumBaseObjectTypeIds.CMIS_RELATIONSHIP);
      actions.setCanDeleteObject(true) /* TODO */;
      actions.setCanDeleteContentStream(type.getBaseId() == EnumBaseObjectTypeIds.CMIS_DOCUMENT
         && ((CmisTypeDocumentDefinitionType)type).getContentStreamAllowed() != EnumContentStreamAllowed.REQUIRED);
      actions.setCanDeleteTree(type.getBaseId() == EnumBaseObjectTypeIds.CMIS_FOLDER);
      actions.setCanGetACL(type.isControllableACL());
      actions.setCanGetAllVersions(type.getBaseId() == EnumBaseObjectTypeIds.CMIS_DOCUMENT);
      actions.setCanGetAppliedPolicies(type.isControllablePolicy());
      actions.setCanGetChildren(type.getBaseId() == EnumBaseObjectTypeIds.CMIS_FOLDER);
      actions.setCanGetContentStream(type.getBaseId() == EnumBaseObjectTypeIds.CMIS_DOCUMENT
         && ((CmisTypeDocumentDefinitionType)type).getContentStreamAllowed() != EnumContentStreamAllowed.NOTALLOWED);
      actions.setCanGetDescendants(type.getBaseId() == EnumBaseObjectTypeIds.CMIS_FOLDER);
      actions.setCanGetFolderParent(type.getBaseId() == EnumBaseObjectTypeIds.CMIS_FOLDER);
      actions.setCanGetFolderTree(type.getBaseId() == EnumBaseObjectTypeIds.CMIS_FOLDER);
      actions.setCanGetObjectParents(type.isFileable());
      actions.setCanGetObjectRelationships(type.getBaseId() != EnumBaseObjectTypeIds.CMIS_RELATIONSHIP);
      actions.setCanGetProperties(true);
      actions.setCanGetRenditions(type.getBaseId() == EnumBaseObjectTypeIds.CMIS_DOCUMENT);
      actions.setCanMoveObject(type.isFileable());
      actions.setCanRemoveObjectFromFolder(type.isFileable());
      actions.setCanRemovePolicy(type.isControllablePolicy());
      actions.setCanSetContentStream(type.getBaseId() == EnumBaseObjectTypeIds.CMIS_DOCUMENT
         && ((CmisTypeDocumentDefinitionType)type).getContentStreamAllowed() != EnumContentStreamAllowed.NOTALLOWED);
      actions.setCanUpdateProperties(true) /* TODO */;
      return actions;
   }

   private CmisObjectType getFolderParent(String folderId, Collection<String> properties)
   {
      return null;

   }

   private String getId(CmisPropertiesType properties)
   {
      CmisPropertyId property = (CmisPropertyId)getProperty(properties, CMIS.OBJECT_ID);
      if (property != null && property.getValue().size() > 0)
         return property.getValue().get(0);
      return null;
   }

   private String getName(CmisPropertiesType properties)
   {
      CmisPropertyString property = (CmisPropertyString)getProperty(properties, CMIS.NAME);
      if (property != null && property.getValue().size() > 0)
         return property.getValue().get(0);
      return null;
   }

   private Map<String, Set<String>> getPermissionMap(CmisAccessControlListType cmisACL)
   {
      Map<String, Set<String>> permissionMap = new HashMap<String, Set<String>>();
      if (cmisACL != null)
      {
         for (CmisAccessControlEntryType ace : cmisACL.getPermission())
         {
            CmisAccessControlPrincipalType principal = ace.getPrincipal();
            String principalId;
            if (principal == null)
            {
               principalId = InMemStorage.ANY;
            }
            else
            {
               principalId = principal.getPrincipalId();
               if (principalId == null)
                  principalId = InMemStorage.ANY;
            }
            if (ace.getPermission().size() > 0)
            {
               Set<String> permissionSet = new CopyOnWriteArraySet<String>();
               for (String permission : ace.getPermission())
               {
                  if (permission != null)
                  {
                     try
                     {
                        EnumBasicPermissions.fromValue(permission);
                     }
                     catch (IllegalArgumentException e)
                     {
                        throw new ConstraintException("Unsupported permission type " + permission);
                     }
                     permissionSet.add(permission);
                  }
               }
               permissionMap.put(principalId, permissionSet);
            }
         }
      }
      return permissionMap;
   }

   private CmisProperty getProperty(CmisPropertiesType all, String propertyId)
   {
      if (all != null)
      {
         List<CmisProperty> props = all.getProperty();
         for (CmisProperty prop : props)
         {
            if (prop.getPropertyDefinitionId().equals(propertyId))
               return prop;
         }
      }
      return null;
   }

   private CmisPropertyDefinitionType getPropertyDefinition(List<CmisPropertyDefinitionType> all, String propertyId)
   {
      if (all != null)
      {
         for (CmisPropertyDefinitionType propDef : all)
         {
            if (propDef.getId().equals(propertyId))
               return propDef;
         }
      }
      return null;
   }

   private String getTypeId(CmisPropertiesType properties)
   {
      CmisPropertyId property = (CmisPropertyId)getProperty(properties, CMIS.OBJECT_TYPE_ID);
      if (property != null && property.getValue().size() > 0)
         return property.getValue().get(0);
      return null;
   }

   private String getBaseTypeId(CmisPropertiesType properties)
   {
      CmisPropertyId property = (CmisPropertyId)getProperty(properties, CMIS.BASE_TYPE_ID);
      if (property != null && property.getValue().size() > 0)
         return property.getValue().get(0);
      return null;
   }

   /**
    * Parse property filter string.
    * 
    * @param propertyFilter the string that contains either '*' or
    *        comma-separated list of properties names. An arbitrary number of
    *        space allowed before and after each comma.
    * @param typeDefinition type definition if filter is '*' then type
    *        definition will be used for getting set of allowable property names
    * @return set of property names
    * @throws FilterNotValidException if <code>filterString</code> is invalid
    */
   private Collection<String> parsePropertyFilter(String propertyFilter, CmisTypeDefinitionType typeDefinition)
      throws FilterNotValidException
   {
      if (propertyFilter != null && propertyFilter.length() > 0)
         propertyFilter = propertyFilter.trim();

      boolean wildcard = propertyFilter == null || propertyFilter.length() == 0 || CMIS.WILDCARD.equals(propertyFilter);

      Set<String> result = new HashSet<String>();
      if (!wildcard)
      {
         for (String token : SPLITTER.split(propertyFilter))
         {
            if (token.length() > 0 && !token.equals(CMIS.WILDCARD))
            {
               for (char ch : token.toCharArray())
               {
                  if (Character.isWhitespace(ch) || ILLEGAL_CHARACTERS.indexOf(ch) != -1)
                     throw new FilterNotValidException("Invalid filter \"" + propertyFilter
                        + "\" contains illegal characters.");
               }
               result.add(token);
            }
            else
            {
               // String contains empty token or some tokens and special token '*'
               throw new FilterNotValidException("Invalid filter \"" + propertyFilter
                  + "\". Filter must contains either '*' OR comma-separated list of properties.");
            }
         }
      }
      else
      {
         List<CmisPropertyDefinitionType> propertyDefinitions = typeDefinition.getPropertyDefinition();
         for (CmisPropertyDefinitionType def : propertyDefinitions)
            result.add(def.getQueryName());
      }

      return result;
   }

   /**
    * Check is folder <code>folderId</code> is valid folder to be used as parent
    * for object with type <code>typeId</code>.
    * 
    * @param folderId folder id
    * @param childTypeId child type id
    * @throws ConstraintException if folder may not be used as parent
    */
   private void validateFolder(String folderId, String childTypeId) throws ConstraintException
   {
      CmisObjectType folder;
      try
      {
         folder =
            getObject(folderId, false, EnumIncludeRelationships.NONE, false, false,
               "cmis:objectTypeId,cmis:baseTypeId,cmis:allowedChildObjectTypeIds", "cmis:none");
      }
      catch (FilterNotValidException e)
      {
         // this shouldn't happen, because filter is prepared and valid
         throw new CmisRuntimeException(e);
      }

      String baseTypeId = getBaseTypeId(folder.getProperties());
      if (!CMIS.FOLDER.equals(baseTypeId))
         throw new InvalidArgumentException("Object " + folderId + " is not a folder.");
      CmisPropertyId allowedChilds =
         (CmisPropertyId)getProperty(folder.getProperties(), CMIS.ALLOWED_CHILD_OBJECT_TYPE_IDS);
      if (allowedChilds != null && allowedChilds.getValue().size() > 0
         && !allowedChilds.getValue().contains(childTypeId))
         throw new ConstraintException("Type " + childTypeId + " is not allowed as child for "
            + getTypeId(folder.getProperties()));
   }

}
